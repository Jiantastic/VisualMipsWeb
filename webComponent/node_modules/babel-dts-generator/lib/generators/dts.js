'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.generateNode = generateNode;

var _ast = require('./ast');

var _utils = require('./utils');

var _string = require('./string');

var ROOT = 'root';
var FUNCTION = 'func';
var INTERFACE = 'iface';
var CLASS = 'class';

var generators = {
  ExportAllDeclaration: function ExportAllDeclaration(node, _ref) {
    var root = _ref.root;

    var source = getSource(node.source, root);
    return (0, _ast.createExportAllFrom)(source).fromSource(node);
  },
  ExportNamedDeclaration: function ExportNamedDeclaration(node, _ref2) {
    var root = _ref2.root,
        generate = _ref2.generate;

    if (node.declaration) {
      // This is an export of the kinds
      // * export class Foo {}
      // * export const bar;
      // * export function baz() {}
      var member = generate(node.declaration);

      if (member === null) {
        return null;
      }

      return (0, _ast.createExportDeclaration)(member).fromSource(node);
    } else if (node.source) {
      // This is a re-export of the kind
      // export { foo, bar as baz } from 'bar';

      var source = getSource(node.source, root);
      var specifiers = node.specifiers.map(generate).filter(_utils.id);

      if (specifiers.length === 0) {
        return null;
      }

      return (0, _ast.createExport)(specifiers, source).fromSource(node);
    } else if (node.specifiers) {
      // This is an export of the kind
      // export { foo, bar as baz };

      var _specifiers = node.specifiers.map(generate).filter(_utils.id);

      if (_specifiers.length === 0) {
        return null;
      }

      return (0, _ast.createExport)(_specifiers, null).fromSource(node);
    }

    console.warn('Unknown export named declaration format');
    return null;
  },
  ImportDeclaration: function ImportDeclaration(node, _ref3) {
    var generate = _ref3.generate;

    if (node.specifiers) {
      var importSpecifiers = node.specifiers.filter(function (s) {
        return s.type === 'ImportSpecifier';
      }).map(generate);

      if (importSpecifiers.length === 0) {
        var importOtherSpecifiers = node.specifiers.filter(function (s) {
          return s.type !== 'ImportSpecifier';
        }).map(generate);

        if (importOtherSpecifiers.length === 0) {
          return (0, _ast.createImportDeclaration)(node).fromSource(node);
        }

        // for this case, the specifiers should not be enclosed in {}
        //   import q from 'bat';
        //   import * as foons from 'bun';
        return (0, _ast.createImport)(false, importOtherSpecifiers, node.source.value).fromSource(node);
      }

      // for this case, the specifiers should be enclosed in {}
      //   import {x} from 'bar';
      //   import {y,z as w} from 'baz';
      //   import {default as q2} from 'bat';
      return (0, _ast.createImport)(true, importSpecifiers, node.source.value).fromSource(node);
    }

    return (0, _ast.createImportDeclaration)(node).fromSource(node);
  },
  ImportSpecifier: function ImportSpecifier(node) {
    var local = node.local.name;
    var imported = node.imported.name;

    return (0, _ast.createImportSpecifier)(imported, local).fromSource(node);
  },
  ImportDefaultSpecifier: function ImportDefaultSpecifier(node) {
    var local = node.local.name;

    return (0, _ast.createImportDefaultSpecifier)(local).fromSource(node);
  },
  ImportNamespaceSpecifier: function ImportNamespaceSpecifier(node) {
    var local = node.local.name;

    return (0, _ast.createImportNamespaceSpecifier)(local).fromSource(node);
  },
  VariableDeclaration: function VariableDeclaration(node, _ref4) {
    var generate = _ref4.generate;
    var kind = node.kind;

    var declarations = node.declarations.map(generate).filter(_utils.id);

    if (declarations.length === 0) {
      return null;
    }

    return (0, _ast.createVariableDeclaration)(kind, declarations).fromSource(node);
  },
  VariableDeclarator: function VariableDeclarator(node, _ref5) {
    var shouldExcludeMember = _ref5.shouldExcludeMember;
    var _node$id = node.id,
        name = _node$id.name,
        typeAnnotation = _node$id.typeAnnotation;


    if (shouldExcludeMember(name)) {
      return null;
    }

    var type = getTypeAnnotation(typeAnnotation, 'any');

    return (0, _ast.createVariableDeclarator)(name, type).fromSource(node);
  },
  ExportSpecifier: function ExportSpecifier(node, _ref6) {
    var shouldExcludeMember = _ref6.shouldExcludeMember;

    var local = node.local.name;
    var exported = node.exported.name;

    if (shouldExcludeMember(exported) || local && shouldExcludeMember(local)) {
      return null;
    }

    return (0, _ast.createExportSpecifier)(local, exported).fromSource(node);
  },
  FunctionDeclaration: function FunctionDeclaration(node, ctx) {
    var shouldExcludeMember = ctx.shouldExcludeMember;
    var name = node.id.name,
        returnType = node.returnType,
        p = node.params,
        tp = node.typeParameters;

    if (shouldExcludeMember(name)) {
      return null;
    }

    var params = p.map(generateNode(_extends({}, ctx, { state: FUNCTION })));
    if (params.some(function (a) {
      return a === null;
    })) {
      // There is a argument we were unable to process,
      // so we don't emit the function (as it would end up wrong).
      console.warn('Failed processing arguments for function ' + name + '.');
      return null;
    }

    var type = getTypeAnnotation(returnType);
    var typeParameters = getTypeParameters(tp);
    return (0, _ast.createFunction)(name, params, type, typeParameters).fromSource(node);
  },
  Identifier: function Identifier(node, _ref7) {
    var state = _ref7.state;

    if (state !== FUNCTION) {
      return null;
    }

    var name = node.name,
        typeAnnotation = node.typeAnnotation,
        optional = node.optional;

    var type = getTypeAnnotation(typeAnnotation);

    return (0, _ast.createParam)(name, type, { isOptional: optional }).fromSource(node);
  },
  AssignmentPattern: function AssignmentPattern(node, ctx) {
    var state = ctx.state;

    if (state !== FUNCTION) {
      return null;
    }

    var left = generateNode(ctx)(node.left);
    if (left !== null) {
      return left.asOptional();
    }
    return null;
  },
  ObjectPattern: function ObjectPattern(node, _ref8) {
    var state = _ref8.state;

    if (state !== FUNCTION) {
      return null;
    }

    var props = node.properties.map(function (prop) {
      var key = prop.key.name;
      var value = null;
      var isOptional = false;

      if (prop.value.type === 'ObjectPattern') {
        value = generators.ObjectPattern(prop.value, { state: state });
      }

      if (prop.value.type === 'AssignmentPattern') {
        isOptional = true;
        if (prop.value.left.type === 'ObjectPattern') {
          value = generators.ObjectPattern(prop.value.left, { state: state });
        }
      }

      return (0, _ast.createObjectParamProp)(key, value, isOptional).fromSource(prop);
    });

    var type = getTypeAnnotation(node.typeAnnotation);
    return (0, _ast.createObjectParam)(props, type, false);
  },
  RestElement: function RestElement(node, _ref9) {
    var state = _ref9.state;

    if (state !== FUNCTION) {
      return null;
    }

    var name = node.argument.name,
        typeAnnotation = node.typeAnnotation;

    var type = getTypeAnnotation(typeAnnotation);

    return (0, _ast.createParam)(name, type, { isRest: true }).fromSource(node);
  },
  InterfaceDeclaration: function InterfaceDeclaration(node, ctx) {
    var ignoreEmptyInterfaces = ctx.ignoreEmptyInterfaces,
        shouldExcludeMember = ctx.shouldExcludeMember;
    var name = node.id.name,
        _node$body = node.body,
        indexers = _node$body.indexers,
        properties = _node$body.properties,
        callProperties = _node$body.callProperties,
        e = node.extends,
        tp = node.typeParameters;

    var baseInterfaces = e.map(function (_ref10) {
      var name = _ref10.id.name;
      return name;
    });
    var typeParameters = getTypeParameters(tp);
    var members = [];

    var generate = generateNode(_extends({}, ctx, { state: INTERFACE }));

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var property = _step.value;

        var member = generate(property);
        if (member !== null) {
          members.push(member);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = indexers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var indexer = _step2.value;

        var _member = generate(indexer);
        if (_member !== null) {
          members.push(_member);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = callProperties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var method = _step3.value;

        var _member2 = generate(method);
        if (_member2 !== null) {
          members.push(_member2);
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    if (shouldExcludeMember(name)) {
      return null;
    }

    if (ignoreEmptyInterfaces && baseInterfaces.length === 0 && members.length === 0) {
      return null;
    }

    return (0, _ast.createInterface)(name, members, baseInterfaces, typeParameters).fromSource(node);
  },
  ObjectTypeProperty: function ObjectTypeProperty(node, ctx) {
    var shouldExcludeMember = ctx.shouldExcludeMember;
    var name = node.key.name,
        value = node.value,
        isStatic = node.static,
        optional = node.optional;


    if (shouldExcludeMember(name)) {
      return null;
    }

    if (value.type === 'FunctionTypeAnnotation') {
      var p = value.params,
          returnType = value.returnType,
          rest = value.rest,
          tp = value.typeParameters;
      // There is no way to differeantiate foo: () => void; and
      // foo(): void in interfaces in the babel AST (at least that
      // I've found). Thus these are treated as methods.

      var params = p.map(getFunctionTypeAnnotationParameterNode);
      if (rest) {
        params.push(getFunctionTypeAnnotationParameterNode(rest).asRestParam());
      }

      var _type = getTypeAnnotationString(returnType);
      var typeParameters = getTypeParameters(tp);
      return (0, _ast.createInterfaceMethod)(name, params, _type, typeParameters, isStatic || false, optional).fromSource(node);
    }

    var type = getTypeAnnotationString(value);
    return (0, _ast.createInterfaceProperty)(name, type, isStatic || false, optional).fromSource(node);
  },
  ObjectTypeIndexer: function ObjectTypeIndexer(node) {
    var name = node.id.name,
        value = node.value,
        key = node.key;


    var type = getTypeAnnotationString(value);
    var keyType = getTypeAnnotationString(key);

    return (0, _ast.createInterfaceIndexer)(name, keyType, type).fromSource(node);
  },
  ObjectTypeCallProperty: function ObjectTypeCallProperty(node) {
    var value = node.value;
    var p = value.params,
        returnType = value.returnType,
        rest = value.rest;
    // There is no way to differeantiate foo: () => void; and
    // foo(): void in interfaces in the babel AST (at least that
    // I've found). Thus these are treated as methods.

    var params = p.map(getFunctionTypeAnnotationParameterNode);
    if (rest) {
      params.push(getFunctionTypeAnnotationParameterNode(rest).asRestParam());
    }

    var type = getTypeAnnotationString(returnType);
    return (0, _ast.createInterfaceCall)(params, type).fromSource(node);
  },
  ClassDeclaration: function ClassDeclaration(node, ctx) {
    var shouldExcludeMember = ctx.shouldExcludeMember,
        ignoreEmptyClasses = ctx.ignoreEmptyClasses;
    var name = node.id.name,
        superClass = node.superClass,
        body = node.body,
        tp = node.typeParameters,
        stp = node.superTypeParameters,
        impl = node.implements;

    if (shouldExcludeMember(name)) {
      return null;
    }

    if (superClass && superClass.type !== 'Identifier') {
      console.warn('Only identifiers supported for super classes.');
      return null;
    }

    var generate = generateNode(_extends({}, ctx, { state: CLASS }));
    var superName = superClass ? superClass.name : null;
    var members = body.body.map(generate).filter(_utils.id);
    var typeParameters = getTypeParameters(tp);
    var superTypeParameters = getTypeParameters(stp);
    var impls = impl ? impl.map(generate) : null;

    if (members.length === 0 && ignoreEmptyClasses) {
      return null;
    }

    return (0, _ast.createClass)(name, superName, members, typeParameters, superTypeParameters, impls).fromSource(node);
  },
  ClassImplements: function ClassImplements(node, _ctx) {
    var name = node.id.name,
        tp = node.typeParameters;

    var typeParameters = getTypeParameters(tp);

    return (0, _ast.createImplements)(name, typeParameters).fromSource(node);
  },
  ClassMethod: function ClassMethod(node, ctx) {
    var shouldExcludeMember = ctx.shouldExcludeMember;
    var kind = node.kind,
        computed = node.computed,
        returnType = node.returnType,
        p = node.params,
        tp = node.typeParameters,
        isStatic = node.static,
        n = node.key;


    var params = p.map(generateNode(_extends({}, ctx, { state: FUNCTION })));
    if (params.some(function (a) {
      return a === null;
    })) {
      // There is a argument we were unable to process,
      // so we don't emit the function (as it would end up wrong).
      console.warn('Failed processing arguments for function ' + name + '.');
      return null;
    }

    if (kind === 'constructor') {
      return (0, _ast.createClassConstructor)(params).fromSource(node);
    }

    var type = getTypeAnnotation(returnType);
    var typeParameters = getTypeParameters(tp);
    var name = void 0;
    switch (n.type) {
      case 'Identifier':
        if (shouldExcludeMember(n.name, { computed: computed })) {
          return null;
        }

        name = computed ? '[' + n.name + ']' : n.name;
        break;

      case 'StringLiteral':
        if (shouldExcludeMember(n.value, { computed: computed })) {
          return null;
        }

        name = n.extra.raw;
        break;

      default:
        console.warn('Invalid method name type ' + n.type);
        return null;
    }

    if (node.kind === 'set') {
      // ignore setters
      return null;
    }

    if (node.kind === 'get') {
      return (0, _ast.createClassProperty)(name, type, isStatic).fromSource(node);
    }

    return (0, _ast.createClassMethod)(name, params, type, typeParameters, isStatic).fromSource(node);
  },
  ClassProperty: function ClassProperty(node, ctx) {
    var name = node.key.name,
        typeAnnotation = node.typeAnnotation,
        isStatic = node.static;
    var shouldExcludeMember = ctx.shouldExcludeMember;

    if (shouldExcludeMember(name)) {
      return null;
    }

    var type = getTypeAnnotation(typeAnnotation);
    return (0, _ast.createClassProperty)(name, type, isStatic).fromSource(node);
  }
};

function generateNode(meta) {
  if (!meta.state) {
    meta = _extends({}, meta, { state: ROOT });
  }

  function generate(node) {
    var fn = generators[node.type];

    if (fn) {
      return fn(node, _extends({ generate: generate, shouldExcludeMember: shouldExcludeMember }, meta));
    }

    console.warn(node.type + ' not supported.');
    return null;
  }

  function shouldExcludeMember(memberName) {
    // memberObjectFilter falsy means include all members
    var ignoreMembers = '^_.*';
    if (meta && meta.ignoreMembers) {
      ignoreMembers = meta.ignoreMembers;
    }

    var memberType = typeof ignoreMembers === 'undefined' ? 'undefined' : _typeof(ignoreMembers);
    if (memberType !== 'function' && memberType !== 'string') {
      if (ignoreMembers instanceof RegExp) {
        memberType = 'regexp';
      }
    }

    switch (memberType) {
      case 'function':
        // memberObjectFilter is function means call function passing memberName and exclude if truthy.
        return ignoreMembers(memberName);

      case 'regexp':
        // memberObjectFilter is regex means check regex, exclude if match.
        return memberName.match(ignoreMembers);

      case 'string':
        // memberObjectFilter is string means check create regex from string, exclude if match.
        return memberName.match(new RegExp(ignoreMembers));

      default:
        console.log('warning: ignoreMembers ignored, expected type function, regexp, or string, but received type ' + memberType);
        ignoreMembers = null;
        return false;
    }
  }

  return generate;
}

function getSource(node, root) {
  var value = node.value;

  if (value.substring(0, 2) === './') {
    value = root + value.substring(1);
  }

  return value;
}

function getTypeParameters(typeParameters) {
  if (!typeParameters) {
    return null;
  }

  var type = typeParameters.type,
      params = typeParameters.params;

  if (params.length === 0) {
    return null;
  }

  switch (type) {
    case 'TypeParameterDeclaration':
      return params.map(function (id) {
        return id.name;
      });

    case 'TypeParameterInstantiation':
      return params.map(function (n) {
        return getTypeAnnotationString(n, null);
      });

    default:
      return null;
  }
}

/**
 * @param  {any} annotated the node to get annotation from
 * @param  {string} [defaultType=null] the default type to use if no annotation is found
 */
function getTypeAnnotation(annotated) {
  var defaultType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (!annotated) {
    return defaultType;
  }

  return getTypeAnnotationString(annotated.typeAnnotation, defaultType);
}

function getTypeAnnotationString(annotation) {
  var defaultType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';

  if (!annotation) {
    return defaultType;
  }

  switch (annotation.type) {
    case 'GenericTypeAnnotation':
      var _name = getSimpleTypeAnnotationName(annotation.id);
      if (annotation.typeParameters) {
        var typeParameters = annotation.typeParameters.params.map(getTypeAnnotationString).join(', ');
        return _name + '<' + typeParameters + '>';
      }

      return _name;

    case 'VoidTypeAnnotation':
      return 'void';

    case 'NumberTypeAnnotation':
      return 'number';

    case 'StringTypeAnnotation':
      return 'string';

    case 'AnyTypeAnnotation':
      return 'any';

    case 'BooleanTypeAnnotation':
      return 'boolean';

    case 'ThisTypeAnnotation':
      return 'this';

    case 'StringLiteralTypeAnnotation':
      var type = (0, _string.safeString)(annotation.value);
      return '\'' + type + '\'';

    case 'UnionTypeAnnotation':
      return annotation.types.map(getTypeAnnotationString).join(' | ');

    case 'TypeofTypeAnnotation':
      var argument = getTypeAnnotationString(annotation.argument);
      return 'typeof ' + argument;

    case 'FunctionTypeAnnotation':
      var params = annotation.params.map(getFunctionTypeAnnotationParameter).join(', ');
      var returnType = getTypeAnnotationString(annotation.returnType);
      return '((' + params + ') => ' + returnType + ')';

    case 'ArrayTypeAnnotation':
      var elementType = getTypeAnnotationString(annotation.elementType);
      return elementType + '[]';

    case 'TupleTypeAnnotation':
      var elements = annotation.types.map(getTypeAnnotationString).join(', ');
      return '[' + elements + ']';

    case 'ObjectTypeAnnotation':
      var properties = annotation.properties,
          indexers = annotation.indexers;

      var annotations = properties.map(function (_ref11) {
        var name = _ref11.key.name,
            value = _ref11.value;

        var valueType = getTypeAnnotationString(value);

        return name + ': ' + valueType;
      }).concat(indexers.map(function (_ref12) {
        var name = _ref12.id.name,
            key = _ref12.key,
            value = _ref12.value;

        var keyType = getTypeAnnotationString(key);
        var valueType = getTypeAnnotationString(value);

        return '[' + name + ': ' + keyType + ']: ' + valueType;
      }));

      if (annotations.length === 0) {
        return '{}';
      }

      var annotationsString = annotations.join(', ');

      return '{ ' + annotationsString + ' }';

    default:
      throw new Error('Unsupported type annotation type: ' + annotation.type);
  }
}

function getSimpleTypeAnnotationName(identifier) {
  switch (identifier.type) {
    case 'Identifier':
      return identifier.name;
    case 'QualifiedTypeIdentifier':
      var qualification = identifier.qualification,
          _id = identifier.id;

      var qName = getSimpleTypeAnnotationName(qualification);
      var idName = getSimpleTypeAnnotationName(_id);
      return qName + '.' + idName;
    default:
      throw new Error('Unsupported identifier type: ' + identifier.type);
  }
}

function getFunctionTypeAnnotationParameter(node) {
  var name = node.name.name,
      typeAnnotation = node.typeAnnotation,
      optional = node.optional;

  var type = getTypeAnnotationString(typeAnnotation, 'any');

  return '' + name + (optional ? '?' : '') + ': ' + type;
}

function getFunctionTypeAnnotationParameterNode(node) {
  var name = node.name.name,
      typeAnnotation = node.typeAnnotation,
      optional = node.optional;

  var type = getTypeAnnotationString(typeAnnotation, 'any');

  return (0, _ast.createParam)(name, type, { isOptional: optional });
}