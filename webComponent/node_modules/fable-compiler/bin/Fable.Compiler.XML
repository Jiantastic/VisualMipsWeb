<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Fable.Compiler</name></assembly>
<members>
<member name="M:Fable.FSharp2Fable.Compiler.DeclInfo.IsIgnoredMethod(Microsoft.FSharp.Compiler.SourceCodeServices.FSharpMemberOrFunctionOrValue)">
<summary>
 Is compiler generated (CompareTo...) or belongs to ignored entity?
 (remember F# compiler puts class methods in enclosing modules)
</summary>
</member>
<member name="M:Fable.FSharp2Fable.Helpers.lowerCaseName(Microsoft.FSharp.Compiler.SourceCodeServices.FSharpUnionCase)">
<summary>
 Lower first letter if there&apos;s no explicit compiled name
</summary>
</member>
<member name="M:Fable.FSharp2Fable.Helpers.isPublicMethod(Microsoft.FSharp.Compiler.SourceCodeServices.FSharpMemberOrFunctionOrValue)">
<summary>
 .IsPrivate for members of a private module always evaluate to true (see #696)
 so we just make all members of a private module public until a proper solution comes in FCS
</summary>
</member>
<member name="M:Fable.FSharp2Fable.Identifiers.tryGetBoundExpr(Fable.FSharp2Fable.Context,Microsoft.FSharp.Core.FSharpOption{Fable.AST.SourceLocation},Microsoft.FSharp.Compiler.SourceCodeServices.FSharpMemberOrFunctionOrValue)">
<summary>
 Get corresponding identifier to F# value in current scope
</summary>
</member>
<member name="M:Fable.FSharp2Fable.Identifiers.bindIdentFrom(Fable.FSharp2Fable.IFableCompiler,Fable.FSharp2Fable.Context,Microsoft.FSharp.Compiler.SourceCodeServices.FSharpMemberOrFunctionOrValue)">
<summary>
 Sanitize F# identifier and create new context
</summary>
</member>
<member name="M:Fable.FSharp2Fable.Identifiers.bindIdent(Fable.FSharp2Fable.IFableCompiler,Fable.FSharp2Fable.Context,Fable.AST.Fable.Type,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.SourceCodeServices.FSharpMemberOrFunctionOrValue},System.String)">
<summary>
 Make a sanitized identifier from a tentative name
</summary>
</member>
<member name="M:Fable.FSharp2Fable.Patterns.|RecordMutatingUpdate|_|(Microsoft.FSharp.Compiler.SourceCodeServices.FSharpExpr)">
<summary>
 Record updates as in `{ a with name = &quot;Anna&quot; }`
</summary>
</member>
<member name="M:Fable.FSharp2Fable.Patterns.|CheckArrayLength|_|(Microsoft.FSharp.Compiler.SourceCodeServices.FSharpExpr)">
<summary>
 This matches the boilerplate generated to check an array&apos;s length
 when pattern matching
</summary>
</member>
<member name="M:Fable.FSharp2Fable.Patterns.|CreateEvent|_|(Microsoft.FSharp.Compiler.SourceCodeServices.FSharpExpr)">
<summary>
 This matches the boilerplate generated to wrap .NET events from F#
</summary>
</member>
<member name="M:Fable.FSharp2Fable.Patterns.|TryGetValue|_|(Microsoft.FSharp.Compiler.SourceCodeServices.FSharpExpr)">
<summary>
 This matches the boilerplate F# compiler generates for methods
 like Dictionary.TryGetValue (see #154)
</summary>
</member>
<member name="M:Fable.FSharp2Fable.Types.makeEntity(Fable.FSharp2Fable.IFableCompiler,Microsoft.FSharp.Compiler.SourceCodeServices.FSharpEntity)">
<summary>
 Don&apos;t use this method directly, use IFableCompiler.GetEntity instead
</summary>
</member>
<member name="M:Fable.Fable2Babel.Util.iife(Fable.Fable2Babel.IBabelCompiler,Fable.Fable2Babel.Context,Fable.AST.Fable.Expr)">
<summary>
 Immediately Invoked Function Expression
</summary>
</member>
<member name="M:Fable.Fable2Babel.Util.|Assignments|_|(Fable.AST.Fable.Expr)">
<summary>
 Matches a sequence of assignments and a return value: a.b = 1, a.c = 2, a
</summary>
</member>
<member name="M:Fable.List.isMultiple``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Same as List.length xs &gt; 1
</summary>
</member>
<member name="T:Fable.Replacements.CoreLibPass.MapKind">
<summary>
 Module methods in the core lib can be bound Static or Both (instance and static).
 If they&apos;re bound only statically all methods will be called statically: if there&apos;s an
 instance, it&apos;ll be passed as the first argument and constructors will change to `create`.
</summary>
</member>
<member name="P:Fable.Replacements.AstPass.seqFunctionsImplementedOutside">
<summary>
 Seq functions implemented in other modules to prevent cyclic dependencies
</summary>
</member>
<member name="M:Fable.Replacements.Util.compare``1(``0,Microsoft.FSharp.Core.FSharpOption{Fable.AST.SourceLocation},Microsoft.FSharp.Collections.FSharpList{Fable.AST.Fable.Expr},Microsoft.FSharp.Core.FSharpOption{Fable.AST.BinaryOperator})">
<summary>
 Compare function that will call Util.compare or instance `CompareTo` as appropriate
 If passed an optional binary operator, it will wrap the comparison like `comparison &lt; 0`
</summary>
</member>
</members>
</doc>
